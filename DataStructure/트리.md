
# 트리(Tree)

## 목차
1. [트리의 개념](#1-트리의-개념)
    - [트리란](#트리란)
    - [트리의 특징](#트리의-특징)
2. [트리의 종류](#2-트리의-종류)
    - [이진 탐색 트리](#이진-탐색-트리)
    - [자가 균형 이진 탐색 트리](#자가-균형-이진-탐색-트리)
    - [힙](#힙)
    - [트라이 자료구조](#트라이-자료구조)
3. [References](#3-References)

## 1. 트리의 개념

### 트리란
트리는 계층적 데이터를 표현하는 데 이용하는 비선형 자료구조이다. (방향성이 있는 비순환 그래프이다.)

### 트리의 특징
- 하나의 루트노드와 0개 이상의 하위 트리로 구성되어 있다.
- 데이터를 순차적으로 저장하지 않기 때문에 비선형 자료구조이다.
- 트리 안에 또 다른 트리가 있는 재귀적 자료구조이다.
- 모든 노드가 연결되고 순환을 가지지 않는 그래프이다.
- 노드들이 부모 자식 관계를 갖는 계층적 자료구조이며 모든 자식 노드는 하나의 부모 노드을 갖는다.
- 노드가 n개인 트리는 항상 n-1개의 간선을 가진다.

## 2. 트리의 종류
### 이진 탐색 트리

이진 탐색 트리란 특정한 조건을 만족하는 이진트리이다.

> 이진트리란?
> 각 노드의 자식 노드의 수가 최대 2개인 트리를 뜻한다.

> 특정한 조건이란?
>
> 1. 각 노드들의 키는 중복되지 않아야 한다.
> 2. 루트 노드의 왼쪽 서브트리는 루트 노드의 키보다 작은 키값를 갖는 노드들로 구성되어 있다.
> 3. 루트 노드의 오른쪽 서브트리는 루트 노드의 키보다 큰 키값를 갖는 노드들로 구성되어 있다.
> 4. 루트 노드의 서브 트리도 이진 탐색 트리여야 한다.

<img width="741" alt="Screen Shot 2022-10-18 at 1 34 01 AM" src="https://user-images.githubusercontent.com/59877415/196233098-71a7e255-0d78-4a79-8a46-a391bdda14fe.png">

- 이진 탐색 트리의 특징 때문에 효율적인 탐색 및 삽입, 삭제가 가능하다. (균형이 잡혀있을 경우 O(logn))

> 그림의 이진 탐색트리에서 35를 찾는다면?
>
> 1. 루트노드인 50과 값을 비교하고 찾는 값이 작으므로 left subtree로 내려간다.
> 2. 30과 값을 비교하고 찾는 값이 크므로 right subtree로 내려간다.
> 3. 35를 찾았다.

> 그린의 이진 탐색트리에 65를 삽입한다면?
>
> 1. 루트노드인 50과 값을 비교하고 삽입할 값이 크므로 right subtree로 내려간다.
> 2. 70과 값을 비교하고 삽입할 값이 작으므로 left subtree로 내려간다.
> 3. 60과 값을 비교하고 삽입할 값이 크므로 right subtree로 내려간다.
> 4. 해당 위치에 노드가 없으므로 만들어주고 값에 65를 넣어준다.

- 이진 트리를 순회하는 세가지 방법

  - **중위 순회** : 왼쪽 서브트리 → 루트 → 오른쪽 서브트리의 순으로 트리를 순회하는 방법이다.

    > 위의 그림의 예시에서는 1 30 35 50 60 70 80 순으로 순회하게 된다.

  - **전위 순회** : 루트 → 왼쪽 서브트리 → 오른쪽 서브트리의 순으로 트리를 순회하는 방법이다.

    > 위의 그림의 예시에서는 50 30 1 35 70 60 70 순으로 순회하게 된다.

  - **후위 순회** : 왼쪽 서브트리 → 오른쪽 서브트리 → 루트의 순으로 트리를 순회하는 방법이다.

    > 위의 그림의 예시에서는 1 30 35 50 60 70 80 순으로 순회하게 된다.

### 자가 균형 이진 탐색 트리

> 이진 탐색 트리의 노드들이 한쪽으로 치우칠수록 탐색 및 삽입, 삭제에 걸리는 시간이 늘어나게 된다.
>
> (최악의 경우 링크드리스트와 다를바가 없어져 탐색, 삽입, 삭제에 O(N)의 시간이 걸리게 된다.)
>
> 이러한 경우를 방지하기 위해 트리의 균형이 유지되도록 돕는 트리 자료구조가 바로 자가 균형 이진트리이다.

**자가 균형 이진트리** : 트리에서 노드의 삽입 혹은 삭제가 일어날 때 `균형이 맞도록 조정`이 일어나는 이진트리이다.

> 트리의 균형이 맞다 : 트리의 모든 하위 트리의 높이 차이가 1이하인 상황이다.
>
> 균형 트리 : 균형이 맞는 트리이다.
>
> 편향 트리 : 균형이 맞지 않는 트리이다.

<img width="828" alt="Screen Shot 2022-10-18 at 2 20 17 AM" src="https://user-images.githubusercontent.com/59877415/196242187-7caa59b2-cbb9-4c7e-a29a-d2a403239456.png">

**AVL 트리** : 자가 균형 이진트리의 일종으로 트리에 노드를 삽입 혹은 삭제할 때마다 `자가 균형 조정 메서드`를 호출하여 트리의 균형을 유지한다.

> AVL 트리의 자가 균형 메서드는 회전을 통해 트리의 균형을 유지한다.

<img width="540" alt="Screen Shot 2022-10-18 at 2 20 27 AM" src="https://user-images.githubusercontent.com/59877415/196242226-28cd7440-a29d-448e-84ef-4aa72ef8e717.png">

**Red-Black 트리** : 자가 균형 이진트리의 일종으로 트리에 노드를 삽입 혹은 삭제할 때 `특정한 규칙`을 지키도록 조정이 이루어져 트리의 균형을 유지한다. (특정한 규칙을 준수한다면 트리의 균형이 유지되는 것이 보장된다.)

> Red-Black 트리의 규칙
>
> 1) 각 노드의 색은 red 또는 black이다.
>
> 2) root 노드는 black이다.
>
> 3) 모든 말단노드(leaf node)는 black이다. (NIL이 black이 된다)
>
> 4) red 노드의 자식노드들은 전부 black이다. (즉, red 노드는 연속되어 등장할 수 없다.)
>
> 5) Root 노드에서 시작해서 자손인 leaf노드에 이르는 모든 경로에는 동일한 개수의 black노드가 존재한다.

### 힙

<img width="708" alt="Screen Shot 2022-10-18 at 1 18 40 AM" src="https://user-images.githubusercontent.com/59877415/196229966-c9fc3409-b8bf-46b2-9ee9-f5a8ff8f9dd7.png">

**우선순위 큐**의 구현을 위해 **완전 이진트리**를 이용한 자료구조이다.

- 여러개의 값들 중에서 최댓값(최대 힙) 혹은 최솟값(최소 힙)을 빠르게 찾아내는데 사용한다.

  → 빠르게 최댓값 혹은 최솟값을 찾아내기 위해 힙은 **반정렬 상태** (느슨한 정렬 상태)를 유지한다.

- 삽입 및 삭제 시의 시간 복잡도가 O(n)이다.

- **배열**을 사용해서 구현한다.

  → 삽입 및 삭제시에 **마지막 인덱스에 접근하는 것이 용이**하다.

  <img width="659" alt="Screen Shot 2022-10-18 at 1 27 06 AM" src="https://user-images.githubusercontent.com/59877415/196231715-2db7cfc6-55fe-447a-9d07-1767cbbc1595.png">

  - 0번째 노드는 비워둔다.
  - N번째 노드의 왼쪽 자식의 인덱스 : 2*N
  - N번째 노드의 오른쪽 자식의 인덱스 : 2*N + 1
  - N번째 노드의 부모의 인덱스 : N/2

> 최대 힙 그림에서 7을 삭제한다면?
> 7을 삭제하고 마지막 노드인 3를 그 자리에 놓는다. 이후 자식 노드와의 재귀적 비교를 통해 자신의 자리를 찾아준다.

> 최소 힙 그림에서 3을 삽입한다면?
> 완전 이진트리가 유지되도록 5의 오른쪽 자식 노드를 생성하고 값으로 3을 넣는다. 이후 부모 노드와의 재귀적 비교를 통해 자신의 자리를 찾아준다.

### 트라이 자료구조

<img width="768" alt="Screen Shot 2022-10-18 at 12 58 38 AM" src="https://user-images.githubusercontent.com/59877415/196225917-241514d6-5163-4c74-9003-468457c10119.png">

**문자열을 저장하고 효율적으로 탐색**하기 위한 **트리 형태의 자료구조**이다.

- 문자열을 탐색할 때 속도가 무척 빠르다.

  > 길이가 M인 문자열을 탐색할 때의 시간 복잡도는 O(M)이 된다.
  > (문자열 탐색시 저장된 문자열의 개수에 영향을 받지 않는다.)

- 각 노드들이 자식 노드에 대한 포인터를 저장해야하므로 공간 복잡도가 높을 수 있다. (메모리 측면에서 비효율적일 수 있다.)

## 3. References
[[자료구조] 트리(Tree)의 개념과 정리](https://go-coding.tistory.com/m/7)

[[자료구조] 트리 (Tree)](https://yoongrammer.tistory.com/m/68)

[선형(Linear) / 비선형(NonLinear) 자료구조](https://goodgid.github.io/DS-Linear-and-NonLinear/)

[[자료구조] 이진 탐색 트리 (BST, Binary Search Tree)](https://yoongrammer.tistory.com/m/71)

[이진 탐색 트리와 자가 균형 이진 탐색 트리](https://lgphone.tistory.com/m/90)

[[알고리즘] Red-Black Tree : 레드 블랙 트리](https://blogshine.tistory.com/m/102)

[[자료구조] 트라이 (Trie)](https://velog.io/@kimdukbae/자료구조-트라이-Trie)

[[자료구조] 힙(heap)이란](https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html)

[사진 출처](https://rebro.kr/m/167)
